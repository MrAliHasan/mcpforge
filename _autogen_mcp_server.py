"""
Auto-generated MCP Server tools by MCP-Maker
Source: sqlite

⚠️ DO NOT EDIT THIS FILE DIRECTLY ⚠️
This file is overwritten every time you run `mcp-maker init`.
Add your custom tools to `mcp_server.py` instead.
"""

import os

# Load connection string from environment to prevent credential exposure in source code
DATABASE_URL = os.environ.get("DATABASE_URL")


import sqlite3
import threading


from mcp.server.fastmcp import FastMCP

# ─── Server Setup ───

mcp = FastMCP("sqlite-server")



# ─── Database Connection (Thread-Safe) ───

DB_PATH = DATABASE_URL
if DB_PATH and DB_PATH.startswith("sqlite:///"):
    DB_PATH = DB_PATH[len("sqlite:///"):]
elif DB_PATH and DB_PATH.startswith("sqlite://"):
    DB_PATH = DB_PATH[len("sqlite://"):]
if not DB_PATH:
    DB_PATH = "/var/folders/k2/1ydmv0l505z3dbt_hl9fqc3m0000gp/T/tmpxuy5v6wv.db"

_local = threading.local()


def _get_connection():
    """Get a thread-local SQLite connection (reused across calls)."""
    if not hasattr(_local, "conn") or _local.conn is None:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA journal_mode=WAL")  # Better concurrent read performance
        _local.conn = conn
    return _local.conn

# ─── Consolidated Tools (Large Schema Mode) ───

# Known tables discovered at generation time — prevents SQL injection
_KNOWN_TABLES = { "table_0", "table_1", "table_10", "table_11", "table_12", "table_13", "table_14", "table_15", "table_16", "table_17", "table_18", "table_19", "table_2", "table_20", "table_21", "table_22", "table_23", "table_24", "table_3", "table_4", "table_5", "table_6", "table_7", "table_8", "table_9",  }

def _validate_table(name: str) -> str:
    """Validate that a table name is in the known set to prevent SQL injection."""
    if name not in _KNOWN_TABLES:
        raise ValueError(f"Unknown table: {name}. Available: {', '.join(sorted(_KNOWN_TABLES))}")
    return name


@mcp.tool()
def list_tables() -> list[str]:
    """List all available tables in the database."""
    return sorted(_KNOWN_TABLES)


@mcp.tool()
def describe_table(table_name: str) -> dict:
    """Get the schema (columns and types) for a specific table."""
    table_name = _validate_table(table_name)
    conn = _get_connection()
    try:
        cursor = conn.execute(f'PRAGMA table_info("{table_name}")')
        return {row["name"]: row["type"] for row in cursor.fetchall()}
    except Exception as e:
        raise RuntimeError(f"describe_table failed: {e}") from e

@mcp.tool()
def query_database(table_name: str, filters: dict | None = None, limit: int = 50, offset: int = 0) -> list[dict]:
    """Query a table with optional exact-match filters (e.g. {"status": "active"})."""
    table_name = _validate_table(table_name)
    conn = _get_connection()
    try:
        limit = min(limit, 500)
        query = f'SELECT * FROM "{table_name}"'
        params = []
        if filters:
            conditions = []
            for k, v in filters.items():
                conditions.append(f'"{k}" = ?')
                params.append(v)
            query += " WHERE " + " AND ".join(conditions)
        query += " LIMIT ? OFFSET ?"
        params.extend([limit, offset])
        cursor = conn.execute(query, params)
        return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        raise RuntimeError(f"query_database failed: {e}") from e






# ─── Health Check ───

@mcp.tool()
def server_health() -> dict:
    """Check the health status of this MCP server.

    Returns:
        Server status including source type, table count, and uptime info.
    """
    return {
        "status": "healthy",
        "source_type": "sqlite",
        "tables": 25,
        "version": "mcp-maker",
    }

# ─── Graceful Shutdown ───

import atexit

def _cleanup():
    """Clean up database connections on server shutdown."""
    if hasattr(_local, "conn") and _local.conn:
        try:
            _local.conn.close()
        except Exception:
            pass

atexit.register(_cleanup)
