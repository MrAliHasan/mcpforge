"""
MCP-Maker Server
Source: sqlite

This is your main server file. It is safe to edit!
`mcp-maker init` will NOT overwrite this file if it already exists.

You can add your own custom tools here, and they will be served alongside
the auto-generated tools from `_autogen_tools`.

Run with: mcp-maker serve --file mcp_server.py
Or directly: python mcp_server.py
"""

from _autogen_tools import mcp

# ─── Add Custom Tools Here ───
#
# @mcp.tool()
# def my_custom_tool(name: str) -> str:
#     """A custom tool that does something cool."""
#     return f"Hello, {name}!"
#
# ─── End Custom Tools ───

if __name__ == "__main__":
    mcp.run()
"""
Auto-generated MCP Server tools by MCP-Maker
Source: sqlite

⚠️ DO NOT EDIT THIS FILE DIRECTLY ⚠️
This file is overwritten every time you run `mcp-maker init`.
Add your custom tools to `mcp_server.py` instead.
"""

import traceback
import os
import sys


import sqlite3
import threading


from mcp.server.fastmcp import FastMCP

# ─── Server Setup ───

mcp = FastMCP("sqlite-server")


# ─── Database Connection (Thread-Safe) ───

DB_PATH = DATABASE_URL
if DB_PATH and DB_PATH.startswith("sqlite:///"):
    DB_PATH = DB_PATH[len("sqlite:///"):]
elif DB_PATH and DB_PATH.startswith("sqlite://"):
    DB_PATH = DB_PATH[len("sqlite://"):]
if not DB_PATH:
    DB_PATH = "sqlite:///test.db"

_local = threading.local()


def _get_connection():
    """Get a thread-local SQLite connection (reused across calls)."""
    if not hasattr(_local, "conn") or _local.conn is None:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA journal_mode=WAL")  # Better concurrent read performance
        _local.conn = conn
    return _local.conn



# ═══════════════════════════════════════════════════════
# Table: users
# Columns: id
# ═══════════════════════════════════════════════════════



@mcp.tool()
def list_users(limit: int = 50, offset: int = 0) -> list[dict]:
    """List rows from the 'users' table.

    Args:
        limit: Maximum number of rows to return (default: 50, max: 500).
        offset: Number of rows to skip for pagination.

    Returns:
        List of users records as dictionaries.
    """
    try:
        limit = min(limit, 500)
        conn = _get_connection()
        cursor = conn.execute(
            'SELECT * FROM "users" LIMIT ? OFFSET ?',
            (limit, offset),
        )
        return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        raise RuntimeError(f"list_users failed: {e}") from e



@mcp.tool()
def get_users_by_id(id: int) -> dict | None:
    """Get a single row from 'users' by its id.

    Args:
        id: The id of the record to retrieve.

    Returns:
        The matching record as a dictionary, or None if not found.
    """
    try:
        conn = _get_connection()
        cursor = conn.execute(
            'SELECT * FROM "users" WHERE "id" = ?',
            (id,),
        )
        row = cursor.fetchone()
        return dict(row) if row else None
    except Exception as e:
        raise RuntimeError(f"get_users_by_id failed: {e}") from e



@mcp.tool()
def search_users(query: str, limit: int = 50) -> list[dict]:
    """Search the 'users' table by matching against text columns.

    This uses LIKE pattern matching (case-insensitive). For large tables,
    consider using the semantic_search tool instead for better performance.

    Args:
        query: Search text to match (case-insensitive).
        limit: Maximum results to return (default: 50).

    Returns:
        List of matching records.
    """
    try:
        limit = min(limit, 500)
        conn = _get_connection()
        conditions = []
        params = []

        if not conditions:
            return []

        where_clause = " OR ".join(conditions)
        cursor = conn.execute(
            f'SELECT * FROM "users" WHERE {where_clause} LIMIT ?',
            (*params, limit),
        )
        return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        raise RuntimeError(f"search_users failed: {e}") from e



@mcp.tool()
def count_users() -> int:
    """Get the total number of rows in the 'users' table.

    Returns:
        Total row count.
    """
    try:
        conn = _get_connection()
        cursor = conn.execute('SELECT COUNT(*) as cnt FROM "users"')
        return cursor.fetchone()["cnt"]
    except Exception as e:
        raise RuntimeError(f"count_users failed: {e}") from e



@mcp.tool()
def schema_users() -> dict:
    """Get the schema (column names and types) of the 'users' table.

    Returns:
        Dictionary with column names as keys and types as values.
    """
    return {
        "id": "integer",
    }



