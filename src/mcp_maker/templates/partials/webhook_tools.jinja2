{% if webhooks %}
# ─── Webhook Notifications ───

import threading as _wh_threading
import urllib.request as _wh_urllib
import uuid as _wh_uuid

import ipaddress as _wh_ipaddress

_webhooks: dict[str, dict] = {}
_wh_lock = _wh_threading.Lock()

def _validate_webhook_url(url: str) -> str:
    """Validate webhook URL to prevent SSRF attacks."""
    from urllib.parse import urlparse as _parse_url
    parsed = _parse_url(url)
    if parsed.scheme not in ("http", "https"):
        raise ValueError(f"Invalid URL scheme: {parsed.scheme}. Only http/https allowed.")
    hostname = parsed.hostname
    if not hostname:
        raise ValueError("Invalid URL: no hostname")
    # Block private/link-local IP ranges
    try:
        ip = _wh_ipaddress.ip_address(hostname)
        if ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_reserved:
            raise ValueError(f"Webhook URL must not point to private/internal addresses: {hostname}")
    except ValueError as e:
        if "private" in str(e) or "internal" in str(e):
            raise
        # hostname is a domain name, not an IP — that's fine
    return url

def _fire_webhooks(event: str, table: str, data: dict):
    """Send POST notifications to registered webhook URLs (non-blocking)."""
    with _wh_lock:
        hooks = list(_webhooks.values())
    for hook in hooks:
        if event in hook.get("events", []):
            def _send(url=hook["url"], payload={"event": event, "table": table, "data": data}):
                try:
                    req = _wh_urllib.Request(
                        url,
                        data=_json.dumps(payload, default=str).encode(),
                        headers={"Content-Type": "application/json"},
                        method="POST",
                    )
                    _wh_urllib.urlopen(req, timeout=5)
                except Exception:
                    pass
            _wh_threading.Thread(target=_send, daemon=True).start()

@mcp.tool()
def webhook_register(url: str, events: list[str] | None = None) -> dict:
    """Register a webhook URL to receive notifications on data changes.

    Args:
        url: The URL to send POST notifications to (must be http/https, no private IPs).
        events: List of events to subscribe to: 'insert', 'update', 'delete' (default: all).

    Returns:
        The webhook registration with its ID.
    """
    url = _validate_webhook_url(url)
    webhook_id = str(_wh_uuid.uuid4())[:8]
    if events is None:
        events = ["insert", "update", "delete"]
    with _wh_lock:
        _webhooks[webhook_id] = {"id": webhook_id, "url": url, "events": events}
    return _webhooks[webhook_id]

@mcp.tool()
def webhook_list() -> list[dict]:
    """List all registered webhooks."""
    with _wh_lock:
        return list(_webhooks.values())

@mcp.tool()
def webhook_remove(webhook_id: str) -> dict:
    """Remove a registered webhook.

    Args:
        webhook_id: The ID of the webhook to remove.
    """
    with _wh_lock:
        removed = _webhooks.pop(webhook_id, None)
    if removed:
        return {"removed": True, "id": webhook_id}
    return {"removed": False, "error": f"Webhook '{webhook_id}' not found"}

{% endif %}
