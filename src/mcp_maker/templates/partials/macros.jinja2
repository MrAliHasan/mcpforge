{# ────────────────────────────────────────────────────────────
   macros.jinja2 — Shared template macros for SQL-based templates
   Used by sqlite.jinja2, postgres.jinja2, mysql.jinja2
   ──────────────────────────────────────────────────────────── #}


{# ─── Table Header Comment ─── #}
{% macro table_header(table) %}
# ═══════════════════════════════════════════════════════
# Table: {{ table.name }}
# Columns: {{ table.columns | map(attribute='name') | join(', ') }}
{% if table.row_count is not none %}
# Rows: {{ table.row_count }}
{% endif %}
# ═══════════════════════════════════════════════════════
{% endmacro %}


{# ─── Static Schema Tool (identical across all DBs) ─── #}
{% macro schema_tool(table, ops) %}
{% if 'read' in ops %}
@mcp.tool()
def schema_{{ table.name }}() -> dict:
    """Get the schema (column names and types) of the '{{ table.name }}' table.

    Returns:
        Dictionary with column names as keys and types as values.
    """
    return {
        {% for col in table.columns %}
        "{{ col.name }}": "{{ col.type.value }}",
        {% endfor %}
    }
{% endif %}
{% endmacro %}


{# ─── Consolidated Mode: Table Whitelist + Validator ─── #}
{% macro consolidated_whitelist(tables) %}
# Known tables discovered at generation time — prevents SQL injection
_KNOWN_TABLES = { {% for table in tables %}"{{ table.name }}", {% endfor %} }

def _validate_table(name: str) -> str:
    """Validate that a table name is in the known set to prevent SQL injection."""
    if name not in _KNOWN_TABLES:
        raise ValueError(f"Unknown table: {name}. Available: {', '.join(sorted(_KNOWN_TABLES))}")
    return name
{% endmacro %}


{# ─── Consolidated Mode: list_tables (identical across all DBs) ─── #}
{% macro consolidated_list_tables(ops) %}
{% if 'read' in ops %}
@mcp.tool()
def list_tables() -> list[str]:
    """List all available tables in the database."""
    return sorted(_KNOWN_TABLES)
{% endif %}
{% endmacro %}


{# ─── Type Mapping Helper ─── #}
{% macro python_type(col) %}{{ 'int' if col.type.value == 'integer' else ('float' if col.type.value == 'float' else ('bool' if col.type.value == 'boolean' else 'str')) }}{% endmacro %}


{# ─── Aggregate Tool (GROUP BY + aggregation functions) ─── #}
{% macro aggregate_tool(table, ops, quote_char) %}
{% if 'read' in ops %}
@mcp.tool()
def aggregate_{{ table.name }}(group_by: str, agg_function: str = "count", agg_column: str = "*", limit: int = 20) -> list[dict]:
    """Aggregate data in '{{ table.name }}' using GROUP BY.

    Args:
        group_by: Column to group by (e.g. '{{ table.columns[0].name }}').
        agg_function: Aggregation function — 'count', 'sum', 'avg', 'min', or 'max'.
        agg_column: Column to aggregate (default: '*' for count).
        limit: Maximum groups to return.

    Returns:
        List of dicts with 'group' and 'value' keys.

    Example:
        aggregate_{{ table.name }}(group_by="status", agg_function="count")
        → [{"group": "active", "value": 120}, {"group": "inactive", "value": 30}]
    """
    _valid_cols = { {% for col in table.columns %}"{{ col.name }}", {% endfor %} }
    if group_by not in _valid_cols:
        raise ValueError(f"Invalid group_by column: {group_by}. Available: {', '.join(sorted(_valid_cols))}")
    agg_function = agg_function.upper()
    if agg_function not in ("COUNT", "SUM", "AVG", "MIN", "MAX"):
        raise ValueError(f"Invalid agg_function: {agg_function}. Use: count, sum, avg, min, max")
    if agg_column != "*" and agg_column not in _valid_cols:
        raise ValueError(f"Invalid agg_column: {agg_column}. Available: {', '.join(sorted(_valid_cols))}")
    q = "{{ quote_char }}"
    agg_col_sql = "*" if agg_column == "*" else f'{q}{agg_column}{q}'
    try:
        conn = _get_connection()
        cursor = conn.execute(
            f'SELECT {q}{group_by}{q} as "group", {agg_function}({agg_col_sql}) as "value" '
            f'FROM {q}{{ table.name }}{q} GROUP BY {q}{group_by}{q} ORDER BY "value" DESC LIMIT ?',
            (min(limit, 100),),
        )
        return [dict(row) for row in cursor.fetchall()]
    except Exception as e:
        raise RuntimeError(f"aggregate_{{ table.name }} failed: {e}") from e
{% endif %}
{% endmacro %}

